{"mappings":"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","sources":["./packages/react/menu/src/useMenuTypeahead.tsx","./packages/react/menu/src/Menu.tsx"],"sourcesContent":["import * as React from 'react';\n\nfunction useMenuTypeahead() {\n  const timerRef = React.useRef(0);\n  const searchRef = React.useRef('');\n\n  // Reset `searchRef` 1 second after it was last updated\n  const setSearch = React.useCallback((search: string) => {\n    searchRef.current = search;\n    window.clearTimeout(timerRef.current);\n    timerRef.current = window.setTimeout(() => setSearch(''), 1000);\n  }, []);\n\n  return {\n    onKeyDownCapture: (event: React.KeyboardEvent) => {\n      if (event.key.length === 1 && !(event.ctrlKey || event.altKey || event.metaKey)) {\n        const container = event.currentTarget as HTMLElement;\n        setSearch(searchRef.current + event.key);\n\n        // Stop activating the item if we're still \"searching\", essentially preventing\n        // the spacebar from selecting the item currently focused.\n        // This is also why we use `onKeyDownCapture` rather than `onKeyDown`\n        if (event.key === ' ' && !searchRef.current.startsWith(' ')) {\n          event.stopPropagation();\n        }\n\n        const currentItem = document.activeElement;\n        const currentMatch = currentItem ? getValue(currentItem) : undefined;\n        const values = Array.from(container.querySelectorAll(`[${ITEM_ATTR}]`)).map(getValue);\n        const nextMatch = getNextMatch(values, searchRef.current, currentMatch);\n        const newItem = container.querySelector(`[${ITEM_ATTR}=\"${nextMatch}\"]`);\n\n        if (newItem) {\n          /**\n           * Imperative focus during keydown is risky so we prevent React's batching updates\n           * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n           */\n          setTimeout(() => (newItem as HTMLElement).focus());\n        }\n      }\n    },\n  };\n}\n\n/**\n * This is the \"meat\" of the matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\nconst getValue = (element: Element) => element.getAttribute(ITEM_ATTR) ?? '';\n\nconst ITEM_ATTR = 'data-radix-menu-typeahead-item';\n\ntype UseMenuTypeaheadItemOptions = { textValue: string; disabled?: boolean };\n\nfunction useMenuTypeaheadItem({ textValue, disabled }: UseMenuTypeaheadItemOptions) {\n  return { [ITEM_ATTR]: disabled ? undefined : textValue };\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nexport { useMenuTypeahead, useMenuTypeaheadItem };\n","import * as React from 'react';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { composeRefs, useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { RovingFocusGroup, RovingFocusItem } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { useMenuTypeahead, useMenuTypeaheadItem } from './useMenuTypeahead';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\ntype FocusScopeProps = React.ComponentProps<typeof FocusScope>;\ntype DismissableLayerProps = React.ComponentProps<typeof DismissableLayer>;\ntype RovingFocusGroupProps = React.ComponentProps<typeof RovingFocusGroup>;\n\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst ALL_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n};\n\nconst [MenuProvider, useMenuContext] = createContext<MenuContextValue>(MENU_NAME);\n\ntype MenuOwnProps = {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n};\n\nconst Menu: React.FC<MenuOwnProps> = (props) => {\n  const { open = false, children, onOpenChange } = props;\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  return (\n    <PopperPrimitive.Root>\n      <MenuProvider open={open} onOpenChange={handleOpenChange}>\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype ItemData = { disabled: boolean };\nconst [CollectionSlot, CollectionItemSlot, useCollection] = createCollection<\n  React.ElementRef<typeof MenuItem>,\n  ItemData\n>();\n\ntype MenuContentContextValue = { onItemLeave(): void };\nconst [MenuContentProvider, useMenuContentContext] = createContext<MenuContentContextValue>(\n  CONTENT_NAME\n);\n\ntype MenuContentOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuContentImpl>,\n  {\n    /**\n     * Used to force mounting when more control is needed. Useful when\n     * controlling animation with React animation libraries.\n     */\n    forceMount?: true;\n  }\n>;\n\ntype MenuContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuContentImpl>,\n  MenuContentOwnProps\n>;\n\nconst MenuContent = React.forwardRef((props, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useMenuContext(CONTENT_NAME);\n  return (\n    <Presence present={forceMount || context.open}>\n      <CollectionSlot>\n        <MenuContentImpl\n          data-state={getOpenState(context.open)}\n          {...contentProps}\n          ref={forwardedRef}\n        />\n      </CollectionSlot>\n    </Presence>\n  );\n}) as MenuContentPrimitive;\n\ntype MenuContentImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof PopperPrimitive.Content>,\n  {\n    /**\n     * Whether focus should be trapped within the `MenuContent`\n     * (default: false)\n     */\n    trapFocus?: FocusScopeProps['trapped'];\n\n    /**\n     * Event handler called when auto-focusing on open.\n     * Can be prevented.\n     */\n    onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n\n    /**\n     * Event handler called when auto-focusing on close.\n     * Can be prevented.\n     */\n    onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n    /**\n     * When `true`, hover/focus/click interactions will be disabled on elements outside the `MenuContent`.\n     * Users will need to click twice on outside elements to interact with them:\n     * Once to close the `MenuContent`, and again to trigger the element.\n     */\n    disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n    /**\n     * Event handler called when the escape key is down.\n     * Can be prevented.\n     */\n    onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n\n    /**\n     * Event handler called when the a pointer event happens outside of the `MenuContent`.\n     * Can be prevented.\n     */\n    onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n\n    /**\n     * Event handler called when the focus moves outside of the `MenuContent`.\n     * Can be prevented.\n     */\n    onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n\n    /**\n     * Event handler called when an interaction happens outside the `MenuContent`.\n     * Specifically, when a pointer event happens outside of the `MenuContent` or focus moves outside of it.\n     * Can be prevented.\n     */\n    onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n\n    /**\n     * Whether scrolling outside the `MenuContent` should be prevented\n     * (default: `false`)\n     */\n    disableOutsideScroll?: boolean;\n\n    /**\n     * The direction of navigation between menu items.\n     * @defaultValue ltr\n     */\n    dir?: RovingFocusGroupProps['dir'];\n\n    /**\n     * Whether keyboard navigation should loop around\n     * @defaultValue false\n     */\n    loop?: RovingFocusGroupProps['loop'];\n\n    /**\n     * Whether the `MenuContent` should render in a `Portal`\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype MenuContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Content>,\n  MenuContentImplOwnProps\n>;\n\nconst MenuContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    dir = 'ltr',\n    loop = false,\n    trapFocus,\n    onOpenAutoFocus,\n    onCloseAutoFocus,\n    disableOutsidePointerEvents,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    disableOutsideScroll,\n    portalled,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME);\n  const contentRef = React.useRef<HTMLDivElement>(null);\n  const typeaheadProps = useMenuTypeahead();\n  const { getItems } = useCollection();\n\n  const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n  const [\n    isPermittedPointerDownOutsideEvent,\n    setIsPermittedPointerDownOutsideEvent,\n  ] = React.useState(false);\n\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n  const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n\n  // Make sure the whole tree has focus guards as our `MenuContent` may be\n  // the last element in the DOM (beacuse of the `Portal`)\n  useFocusGuards();\n\n  // Hide everything from ARIA except the `MenuContent`\n  React.useEffect(() => {\n    const content = contentRef.current;\n    if (content) return hideOthers(content);\n  }, []);\n\n  return (\n    <PortalWrapper>\n      <ScrollLockWrapper>\n        <MenuContentProvider\n          onItemLeave={React.useCallback(() => {\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          }, [])}\n        >\n          <FocusScope\n            // clicking outside may raise a focusout event, which may get trapped.\n            // in cases where outside pointer events are permitted, we stop trapping.\n            // we also make sure we're not trapping once it's been closed\n            // (closed !== unmounted when animating out)\n            trapped={isPermittedPointerDownOutsideEvent ? false : trapFocus && context.open}\n            onMountAutoFocus={onOpenAutoFocus}\n            onUnmountAutoFocus={(event) => {\n              // skip autofocus on unmount if clicking outside is permitted and it happened\n              if (isPermittedPointerDownOutsideEvent) {\n                event.preventDefault();\n              } else {\n                onCloseAutoFocus?.(event);\n              }\n            }}\n          >\n            {(focusScopeProps) => (\n              <DismissableLayer\n                disableOutsidePointerEvents={disableOutsidePointerEvents}\n                onEscapeKeyDown={onEscapeKeyDown}\n                onPointerDownOutside={composeEventHandlers(\n                  onPointerDownOutside,\n                  (event) => {\n                    const isLeftClick =\n                      (event as MouseEvent).button === 0 && event.ctrlKey === false;\n                    const isPermitted = !disableOutsidePointerEvents && isLeftClick;\n                    setIsPermittedPointerDownOutsideEvent(isPermitted);\n\n                    if (event.defaultPrevented) {\n                      // reset this because the event was prevented\n                      setIsPermittedPointerDownOutsideEvent(false);\n                    }\n                  },\n                  { checkForDefaultPrevented: false }\n                )}\n                onFocusOutside={composeEventHandlers(\n                  onFocusOutside,\n                  (event) => {\n                    // When focus is trapped, a focusout event may still happen.\n                    // We make sure we don't trigger our `onDismiss` in such case.\n                    if (trapFocus) event.preventDefault();\n                  },\n                  { checkForDefaultPrevented: false }\n                )}\n                onInteractOutside={onInteractOutside}\n                onDismiss={() => context.onOpenChange(false)}\n              >\n                {(dismissableLayerProps) => (\n                  <RovingFocusGroup\n                    as={Slot}\n                    dir={dir}\n                    orientation=\"vertical\"\n                    loop={loop}\n                    currentTabStopId={currentItemId}\n                    onCurrentTabStopIdChange={setCurrentItemId}\n                    // we override the default behaviour which automatically focuses the first item\n                    onEntryFocus={(event) => event.preventDefault()}\n                  >\n                    <PopperPrimitive.Content\n                      role=\"menu\"\n                      {...focusScopeProps}\n                      {...contentProps}\n                      ref={composeRefs(forwardedRef, contentRef, focusScopeProps.ref)}\n                      style={{\n                        ...dismissableLayerProps.style,\n                        outline: 'none',\n                        ...contentProps.style,\n                      }}\n                      onBlurCapture={composeEventHandlers(\n                        contentProps.onBlurCapture,\n                        dismissableLayerProps.onBlurCapture,\n                        { checkForDefaultPrevented: false }\n                      )}\n                      onFocusCapture={composeEventHandlers(\n                        contentProps.onFocusCapture,\n                        dismissableLayerProps.onFocusCapture,\n                        { checkForDefaultPrevented: false }\n                      )}\n                      onMouseDownCapture={composeEventHandlers(\n                        contentProps.onMouseDownCapture,\n                        dismissableLayerProps.onMouseDownCapture,\n                        { checkForDefaultPrevented: false }\n                      )}\n                      onTouchStartCapture={composeEventHandlers(\n                        contentProps.onTouchStartCapture,\n                        dismissableLayerProps.onTouchStartCapture,\n                        { checkForDefaultPrevented: false }\n                      )}\n                      onKeyDownCapture={composeEventHandlers(\n                        contentProps.onKeyDownCapture,\n                        typeaheadProps.onKeyDownCapture\n                      )}\n                      // focus first/last item based on key pressed\n                      onKeyDown={composeEventHandlers(\n                        contentProps.onKeyDown,\n                        composeEventHandlers(focusScopeProps.onKeyDown, (event) => {\n                          const content = contentRef.current;\n                          if (event.target !== content) return;\n                          if (!ALL_KEYS.includes(event.key)) return;\n                          event.preventDefault();\n                          const items = getItems().filter((item) => !item.disabled);\n                          const candidateNodes = items.map((item) => item.ref.current!);\n                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                          focusFirst(candidateNodes);\n                        })\n                      )}\n                    />\n                  </RovingFocusGroup>\n                )}\n              </DismissableLayer>\n            )}\n          </FocusScope>\n        </MenuContentProvider>\n      </ScrollLockWrapper>\n    </PortalWrapper>\n  );\n}) as MenuContentImplPrimitive;\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_DEFAULT_TAG = 'div';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemOwnProps = Polymorphic.Merge<\n  Omit<Polymorphic.OwnProps<typeof RovingFocusItem>, 'focusable' | 'active'>,\n  {\n    disabled?: boolean;\n    textValue?: string;\n    onSelect?: (event: Event) => void;\n  }\n>;\n\ntype MenuItemPrimitive = Polymorphic.ForwardRefComponent<typeof ITEM_DEFAULT_TAG, MenuItemOwnProps>;\n\nconst MenuItem = React.forwardRef((props, forwardedRef) => {\n  const { as = ITEM_DEFAULT_TAG, disabled = false, textValue, onSelect, ...itemProps } = props;\n  const ref = React.useRef<HTMLDivElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const context = useMenuContext(ITEM_NAME);\n  const contentContext = useMenuContentContext(ITEM_NAME);\n\n  // get the item's `.textContent` as default strategy for typeahead `textValue`\n  const [textContent, setTextContent] = React.useState('');\n  React.useEffect(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      setTextContent((menuItem.textContent ?? '').trim());\n    }\n  }, [itemProps.children]);\n\n  const menuTypeaheadItemProps = useMenuTypeaheadItem({\n    textValue: textValue ?? textContent,\n    disabled,\n  });\n\n  const handleSelect = () => {\n    const menuItem = ref.current;\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new Event(ITEM_SELECT, { bubbles: true, cancelable: true });\n      menuItem.dispatchEvent(itemSelectEvent);\n      if (itemSelectEvent.defaultPrevented) return;\n      context.onOpenChange?.(false);\n    }\n  };\n\n  React.useEffect(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      const handleItemSelect = (event: Event) => onSelect?.(event);\n      menuItem.addEventListener(ITEM_SELECT, handleItemSelect);\n      return () => menuItem.removeEventListener(ITEM_SELECT, handleItemSelect);\n    }\n  }, [onSelect]);\n\n  return (\n    <CollectionItemSlot disabled={disabled}>\n      <RovingFocusItem\n        role=\"menuitem\"\n        aria-disabled={disabled || undefined}\n        focusable={!disabled}\n        {...itemProps}\n        {...menuTypeaheadItemProps}\n        as={as}\n        ref={composedRefs}\n        data-disabled={disabled ? '' : undefined}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (!disabled && (event.key === 'Enter' || event.key === ' ')) {\n            // prevent page scroll if using the space key to select an item\n            if (event.key === ' ') event.preventDefault();\n            handleSelect();\n          }\n        })}\n        // we handle selection on `mouseUp` rather than `click` to match native menus implementation\n        onMouseUp={composeEventHandlers(props.onMouseUp, handleSelect)}\n        /**\n         * We focus items on `mouseMove` to achieve the following:\n         *\n         * - Mouse over an item (it focuses)\n         * - Leave mouse where it is and use keyboard to focus a different item\n         * - Wiggle mouse without it leaving previously focused item\n         * - Previously focused item should re-focus\n         *\n         * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n         * wiggles. This is to match native menu implementation.\n         */\n        onMouseMove={composeEventHandlers(props.onMouseMove, (event) => {\n          if (!disabled) {\n            const item = event.currentTarget;\n            item.focus();\n          } else {\n            contentContext.onItemLeave();\n          }\n        })}\n        onMouseLeave={composeEventHandlers(props.onMouseLeave, () => contentContext.onItemLeave())}\n      />\n    </CollectionItemSlot>\n  );\n}) as MenuItemPrimitive;\n\nMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuItem>,\n  {\n    checked?: boolean;\n    onCheckedChange?: (checked: boolean) => void;\n  }\n>;\n\ntype MenuCheckboxItemPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuItem>,\n  MenuCheckboxItemOwnProps\n>;\n\nconst MenuCheckboxItem = React.forwardRef((props, forwardedRef) => {\n  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n  return (\n    <ItemIndicatorContext.Provider value={checked}>\n      <MenuItem\n        role=\"menuitemcheckbox\"\n        aria-checked={checked}\n        {...checkboxItemProps}\n        ref={forwardedRef}\n        data-state={getCheckedState(checked)}\n        onSelect={composeEventHandlers(\n          checkboxItemProps.onSelect,\n          () => onCheckedChange?.(!checked),\n          { checkForDefaultPrevented: false }\n        )}\n      />\n    </ItemIndicatorContext.Provider>\n  );\n}) as MenuCheckboxItemPrimitive;\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst RadioGroupContext = React.createContext<MenuRadioGroupOwnProps>({} as any);\n\ntype MenuRadioGroupOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuGroup>,\n  {\n    value?: string;\n    onValueChange?: (value: string) => void;\n  }\n>;\n\ntype MenuRadioGroupPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuGroup>,\n  MenuRadioGroupOwnProps\n>;\n\nconst MenuRadioGroup = React.forwardRef((props, forwardedRef) => {\n  const { value, onValueChange, ...groupProps } = props;\n  const handleValueChange = useCallbackRef(onValueChange);\n  const context = React.useMemo(() => ({ value, onValueChange: handleValueChange }), [\n    value,\n    handleValueChange,\n  ]);\n  return (\n    <RadioGroupContext.Provider value={context}>\n      <MenuGroup {...groupProps} ref={forwardedRef} />\n    </RadioGroupContext.Provider>\n  );\n}) as MenuRadioGroupPrimitive;\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuItem>,\n  { value: string }\n>;\ntype MenuRadioItemPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuItem>,\n  MenuRadioItemOwnProps\n>;\n\nconst MenuRadioItem = React.forwardRef((props, forwardedRef) => {\n  const { value, ...radioItemProps } = props;\n  const context = React.useContext(RadioGroupContext);\n  const checked = value === context.value;\n  return (\n    <ItemIndicatorContext.Provider value={checked}>\n      <MenuItem\n        role=\"menuitemradio\"\n        aria-checked={checked}\n        {...radioItemProps}\n        ref={forwardedRef}\n        data-state={getCheckedState(checked)}\n        onSelect={composeEventHandlers(\n          radioItemProps.onSelect,\n          () => context.onValueChange?.(value),\n          { checkForDefaultPrevented: false }\n        )}\n      />\n    </ItemIndicatorContext.Provider>\n  );\n}) as MenuRadioItemPrimitive;\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\nconst ITEM_INDICATOR_DEFAULT_TAG = 'span';\n\nconst ItemIndicatorContext = React.createContext(false);\n\ntype MenuItemIndicatorOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  {\n    /**\n     * Used to force mounting when more control is needed. Useful when\n     * controlling animation with React animation libraries.\n     */\n    forceMount?: true;\n  }\n>;\n\ntype MenuItemIndicatorPrimitive = Polymorphic.ForwardRefComponent<\n  typeof ITEM_INDICATOR_DEFAULT_TAG,\n  MenuItemIndicatorOwnProps\n>;\n\nconst MenuItemIndicator = React.forwardRef((props, forwardedRef) => {\n  const { as = ITEM_INDICATOR_DEFAULT_TAG, forceMount, ...indicatorProps } = props;\n  const checked = React.useContext(ItemIndicatorContext);\n  return (\n    <Presence present={forceMount || checked}>\n      <Primitive\n        {...indicatorProps}\n        as={as}\n        ref={forwardedRef}\n        data-state={getCheckedState(checked)}\n      />\n    </Presence>\n  );\n}) as MenuItemIndicatorPrimitive;\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst MenuAnchor = extendPrimitive(PopperPrimitive.Anchor, { displayName: 'MenuAnchor' });\nconst MenuGroup = extendPrimitive(Primitive, {\n  defaultProps: { role: 'group' },\n  displayName: 'MenuGroup',\n});\nconst MenuLabel = extendPrimitive(Primitive, { displayName: 'MenuLabel' });\nconst MenuSeparator = extendPrimitive(Primitive, {\n  defaultProps: { role: 'separator', 'aria-orientation': 'horizontal' },\n  displayName: 'MenuSeparator ',\n});\nconst MenuArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'MenuArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction getCheckedState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\n\nexport {\n  Menu,\n  MenuAnchor,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n};\nexport type {\n  MenuContentPrimitive,\n  MenuItemPrimitive,\n  MenuCheckboxItemPrimitive,\n  MenuRadioGroupPrimitive,\n  MenuRadioItemPrimitive,\n  MenuItemIndicatorPrimitive,\n};\n"],"names":["useMenuTypeahead","timerRef","React","useRef","searchRef","setSearch","useCallback","search","current","window","clearTimeout","setTimeout","onKeyDownCapture","event","key","length","ctrlKey","altKey","metaKey","container","currentTarget","startsWith","stopPropagation","currentItem","document","activeElement","currentMatch","getValue","undefined","nextMatch","values","normalizedSearch","Array","from","every","char","currentMatchIndex","indexOf","wrappedValues","array","startIndex","Math","max","map","_","index","filter","v","find","value","toLowerCase","getNextMatch","querySelectorAll","ITEM_ATTR","newItem","querySelector","focus","element","_element$getAttribute","getAttribute","LAST_KEYS","ALL_KEYS","MenuProvider","useMenuContext","createContext","Menu","props","open","children","onOpenChange","handleOpenChange","useCallbackRef","_react","createElement","_radixUiReactPopper","Root","$e9e2cf92950df0b951e7bac95d18$var$MenuProvider","CollectionSlot","CollectionItemSlot","useCollection","createCollection","MenuContentProvider","useMenuContentContext","MenuContent","forwardRef","forwardedRef","forceMount","contentProps","context","Presence","present","$e9e2cf92950df0b951e7bac95d18$var$CollectionSlot","$e9e2cf92950df0b951e7bac95d18$var$MenuContentImpl","_babelRuntimeHelpersEsmExtends","data-state","ref","MenuContentImpl","dir","loop","trapFocus","onOpenAutoFocus","onCloseAutoFocus","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","disableOutsideScroll","portalled","contentRef","typeaheadProps","$d5f118c61d28e2c75ed88b93df338dde$export$useMenuTypeahead","getItems","currentItemId","setCurrentItemId","useState","isPermittedPointerDownOutsideEvent","setIsPermittedPointerDownOutsideEvent","PortalWrapper","Portal","Fragment","ScrollLockWrapper","RemoveScroll","useFocusGuards","useEffect","content","hideOthers","$e9e2cf92950df0b951e7bac95d18$var$MenuContentProvider","onItemLeave","_contentRef$current","FocusScope","trapped","onMountAutoFocus","onUnmountAutoFocus","preventDefault","focusScopeProps","DismissableLayer","composeEventHandlers","isLeftClick","button","defaultPrevented","checkForDefaultPrevented","onDismiss","dismissableLayerProps","RovingFocusGroup","as","Slot","orientation","currentTabStopId","onCurrentTabStopIdChange","onEntryFocus","Content","role","composeRefs","style","outline","onBlurCapture","onFocusCapture","onMouseDownCapture","onTouchStartCapture","onKeyDown","target","includes","candidateNodes","item","disabled","reverse","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","focusFirst","ITEM_DEFAULT_TAG","MenuItem","textValue","onSelect","itemProps","composedRefs","useComposedRefs","contentContext","textContent","setTextContent","menuItem","_menuItem$textContent","trim","menuTypeaheadItemProps","[object Object]","$d5f118c61d28e2c75ed88b93df338dde$export$useMenuTypeaheadItem","handleSelect","_context$onOpenChange","itemSelectEvent","Event","bubbles","cancelable","dispatchEvent","call","handleItemSelect","addEventListener","removeEventListener","$e9e2cf92950df0b951e7bac95d18$var$CollectionItemSlot","RovingFocusItem","aria-disabled","focusable","data-disabled","onMouseUp","onMouseMove","onMouseLeave","MenuCheckboxItem","checked","onCheckedChange","checkboxItemProps","$e9e2cf92950df0b951e7bac95d18$var$ItemIndicatorContext","Provider","aria-checked","getCheckedState","RadioGroupContext","MenuRadioGroup","onValueChange","groupProps","handleValueChange","useMemo","$e9e2cf92950df0b951e7bac95d18$var$RadioGroupContext","MenuGroup","MenuRadioItem","radioItemProps","useContext","_context$onValueChang","ITEM_INDICATOR_DEFAULT_TAG","ItemIndicatorContext","MenuItemIndicator","indicatorProps","Primitive","MenuAnchor","extendPrimitive","PopperPrimitive","Anchor","displayName","defaultProps","MenuLabel","MenuSeparator","aria-orientation","MenuArrow","Arrow","Group","Label","Item","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator"],"version":3,"file":"index.module.js.map"}