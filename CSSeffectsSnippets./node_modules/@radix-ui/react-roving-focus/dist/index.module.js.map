{"mappings":"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","sources":["./packages/react/roving-focus/src/RovingFocusGroup.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [CollectionSlot, CollectionItemSlot, useCollection] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>();\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\nconst GROUP_DEFAULT_TAG = 'span';\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ntype RovingFocusGroupOptions = {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   * @defaultValue ltr\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n};\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] = createContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupOwnProps = Polymorphic.OwnProps<typeof RovingFocusGroupImpl>;\n\ntype RovingFocusGroupPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof RovingFocusGroupImpl>,\n  RovingFocusGroupOwnProps\n>;\n\nconst RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return (\n    <CollectionSlot>\n      <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n    </CollectionSlot>\n  );\n}) as RovingFocusGroupPrimitive;\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\ntype RovingFocusGroupImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  RovingFocusGroupOptions & {\n    currentTabStopId?: string | null;\n    defaultCurrentTabStopId?: string;\n    onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n    onEntryFocus?: (event: Event) => void;\n  }\n>;\n\ntype RovingFocusGroupImplPrimitive = Polymorphic.ForwardRefComponent<\n  typeof GROUP_DEFAULT_TAG,\n  RovingFocusGroupImplOwnProps\n>;\n\nconst RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    as = GROUP_DEFAULT_TAG,\n    orientation,\n    dir = 'ltr',\n    loop = false,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<React.ElementRef<typeof RovingFocusGroup>>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const { getItems } = useCollection();\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      orientation={orientation}\n      dir={dir}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback((tabStopId) => setCurrentTabStopId(tabStopId), [\n        setCurrentTabStopId,\n      ])}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        aria-orientation={orientation}\n        data-orientation={orientation}\n        {...groupProps}\n        as={as}\n        ref={composedRefs}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          if (event.target === event.currentTarget && !isTabbingBackOut) {\n            const entryFocusEvent = new Event(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n}) as RovingFocusGroupImplPrimitive;\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusItem';\nconst ITEM_DEFAULT_TAG = 'span';\n\ntype RovingFocusItemOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  {\n    focusable?: boolean;\n    active?: boolean;\n  }\n>;\n\ntype RovingFocusItemPrimitive = Polymorphic.ForwardRefComponent<\n  typeof ITEM_DEFAULT_TAG,\n  RovingFocusItemOwnProps\n>;\n\nconst RovingFocusItem = React.forwardRef((props, forwardedRef) => {\n  const { as = ITEM_DEFAULT_TAG, focusable = true, active = false, ...itemProps } = props;\n  const id = useId();\n  const context = useRovingFocusContext(ITEM_NAME);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const { getItems } = useCollection();\n\n  return (\n    <CollectionItemSlot id={id} focusable={focusable} active={active}>\n      <Primitive\n        tabIndex={isCurrentTabStop ? 0 : -1}\n        data-orientation={context.orientation}\n        {...itemProps}\n        as={as}\n        ref={forwardedRef}\n        onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n          // We prevent focusing non-focusable items on `mousedown`.\n          // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n          if (!focusable) event.preventDefault();\n        })}\n        onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Tab' && event.shiftKey) {\n            context.onItemShiftTab();\n            return;\n          }\n\n          if (event.target !== event.currentTarget) return;\n\n          const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n          if (focusIntent !== undefined) {\n            event.preventDefault();\n            const items = getItems().filter((item) => item.focusable);\n            let candidateNodes = items.map((item) => item.ref.current!);\n\n            if (focusIntent === 'last') candidateNodes.reverse();\n            else if (focusIntent === 'prev' || focusIntent === 'next') {\n              if (focusIntent === 'prev') candidateNodes.reverse();\n              const currentIndex = candidateNodes.indexOf(event.currentTarget);\n              candidateNodes = context.loop\n                ? wrapArray(candidateNodes, currentIndex + 1)\n                : candidateNodes.slice(currentIndex + 1);\n            }\n\n            /**\n             * Imperative focus during keydown is risky so we prevent React's batching updates\n             * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n             */\n            setTimeout(() => focusFirst(candidateNodes));\n          }\n        })}\n      />\n    </CollectionItemSlot>\n  );\n}) as RovingFocusItemPrimitive;\n\nRovingFocusItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusItem;\n\nexport {\n  RovingFocusGroup,\n  RovingFocusItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupPrimitive, RovingFocusItemPrimitive };\n"],"names":["EVENT_OPTIONS","bubbles","cancelable","CollectionSlot","CollectionItemSlot","useCollection","createCollection","GROUP_DEFAULT_TAG","RovingFocusProvider","useRovingFocusContext","createContext","RovingFocusGroup","React","forwardRef","props","forwardedRef","_react","createElement","$aa7392b6d04813384a511e60e09$var$CollectionSlot","$aa7392b6d04813384a511e60e09$var$RovingFocusGroupImpl","_babelRuntimeHelpersEsmExtends","ref","RovingFocusGroupImpl","as","orientation","dir","loop","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","groupProps","useRef","composedRefs","useComposedRefs","setCurrentTabStopId","useControllableState","prop","defaultProp","onChange","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","useCallbackRef","getItems","useEffect","node","current","addEventListener","removeEventListener","$aa7392b6d04813384a511e60e09$var$RovingFocusProvider","onItemFocus","useCallback","tabStopId","onItemShiftTab","Primitive","tabIndex","aria-orientation","data-orientation","onFocus","composeEventHandlers","event","target","currentTarget","entryFocusEvent","Event","dispatchEvent","defaultPrevented","items","filter","item","focusable","focusFirst","find","active","id","Boolean","map","onBlur","ITEM_DEFAULT_TAG","RovingFocusItem","itemProps","useId","context","isCurrentTabStop","$aa7392b6d04813384a511e60e09$var$CollectionItemSlot","onMouseDown","preventDefault","onKeyDown","key","shiftKey","focusIntent","getDirectionAwareKey","includes","MAP_KEY_TO_FOCUS_INTENT","getFocusIntent","undefined","candidateNodes","reverse","currentIndex","indexOf","startIndex","array","_","index","length","slice","setTimeout","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","candidates","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","Root","Item"],"version":3,"file":"index.module.js.map"}