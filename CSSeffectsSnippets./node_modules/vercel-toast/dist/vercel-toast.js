var toast = (() => {
  var __defineProperty = Object.defineProperty;
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __markAsModule = (target) => {
    return __defineProperty(target, "__esModule", {value: true});
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defineProperty(target, name, {get: all[name], enumerable: true});
  };

  // src/index.ts
  var require_src = __commonJS((exports) => {
    __export(exports, {
      Toast: () => Toast,
      createToast: () => createToast,
      destoryAllToasts: () => destoryAllToasts
    });
    const waitFor = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    let instances = new Set();
    let container;
    class Toast {
      constructor(message, options = {}) {
        const {timeout = 0, action, type = "default", cancel} = options;
        this.message = message;
        this.options = {
          timeout,
          action,
          type,
          cancel
        };
        this.setContainer();
        this.insert();
        instances.add(this);
      }
      insert() {
        const el = document.createElement("div");
        el.className = "toast";
        el.setAttribute("aria-live", "assertive");
        el.setAttribute("aria-atomic", "true");
        el.setAttribute("aria-hidden", "false");
        const {action, type, cancel} = this.options;
        const inner = document.createElement("div");
        inner.className = "toast-inner";
        const text = document.createElement("div");
        text.className = "toast-text";
        inner.classList.add(type);
        if (typeof this.message === "string") {
          text.textContent = this.message;
        } else {
          text.appendChild(this.message);
        }
        inner.appendChild(text);
        if (cancel) {
          const button = document.createElement("button");
          button.className = "toast-button cancel-button";
          button.textContent = cancel;
          button.type = "text";
          button.onclick = () => this.destory();
          inner.appendChild(button);
        }
        if (action) {
          const button = document.createElement("button");
          button.className = "toast-button";
          button.textContent = action.text;
          button.type = "text";
          button.onclick = () => {
            this.stopTimer();
            if (action.callback) {
              action.callback(this);
            } else {
              this.destory();
            }
          };
          inner.appendChild(button);
        }
        el.appendChild(inner);
        this.startTimer();
        this.el = el;
        container.appendChild(el);
        waitFor(50).then(sortToast);
      }
      destory() {
        const {el} = this;
        if (!el)
          return;
        container.removeChild(el);
        instances.delete(this);
        sortToast();
      }
      setContainer() {
        container = document.querySelector(".toast-container");
        if (!container) {
          container = document.createElement("div");
          container.className = "toast-container";
          document.body.appendChild(container);
        }
        container.addEventListener("mouseenter", () => {
          instances.forEach((instance) => instance.stopTimer());
        });
        container.addEventListener("mouseleave", () => {
          instances.forEach((instance) => instance.startTimer());
        });
      }
      startTimer() {
        if (this.options.timeout && !this.timeoutId) {
          this.timeoutId = self.setTimeout(() => this.destory(), this.options.timeout);
        }
      }
      stopTimer() {
        if (this.timeoutId) {
          clearTimeout(this.timeoutId);
          this.timeoutId = void 0;
        }
      }
    }
    function createToast(message, options) {
      return new Toast(message, options);
    }
    function destoryAllToasts() {
      if (!container)
        return;
      instances.clear();
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
    }
    function sortToast() {
      const toasts = Array.from(instances).reverse().slice(0, 4);
      const heights = [];
      toasts.forEach((toast, index) => {
        const sortIndex = index + 1;
        const el = toast.el;
        const height = +(el.getAttribute("data-height") || 0) || el.clientHeight;
        heights.push(height);
        el.className = `toast toast-${sortIndex}`;
        el.dataset.height = "" + height;
        el.style.setProperty("--index", "" + sortIndex);
        el.style.setProperty("--height", height + "px");
        el.style.setProperty("--front-height", `${heights[0]}px`);
        if (sortIndex > 1) {
          const hoverOffsetY = heights.slice(0, sortIndex - 1).reduce((res, next) => res += next, 0);
          el.style.setProperty("--hover-offset-y", `-${hoverOffsetY}px`);
        } else {
          el.style.removeProperty("--hover-offset-y");
        }
      });
    }
  });
  return require_src();
})();
